C# 기술면접 대비 정리
가독성은 추후에..

-객체 지향 프로그래밍
객체 간의 상호작용 방식으로 프로그램을 구성한 것이다.
객체란, 현실 객체에게서 추상화(의미있는 추출) 과정을 통해 기능과 상태를 뽑아내 만든 소프트웨어적인 객체를 의미한다.


-객체의 구성
속성(상태): 필드, 변수, 데이터
기능: 메소드


-데이터 형식
복합 데이터 형식 vs 기본 데이터 형식으로 구성
혹은 값 형식 vs 참조 형식으로 구성
복합 데이터 형식, 기본 데이터 형식 모두 값 형식과 참조 형식 데이터들을 갖고 있음


-복합 데이터 형식 vs 기본 데이터 형식
복합 데이터 형식: 기본 데이터 형식을 부품 삼아 이들을 조립한, 즉 이들로 구성된 또 다른 데이터 형식
구조체, 클래스, 배열 등 (클래스는 참조형)
기본 데이터 형식: 숫자, 논리, 문자열, 오브젝트 등 (문자열, 오브젝트는 참조형)


-스택 vs 힙
스택: LIFO, 쌓여있는 책 형식, 코드 블록이 끝나면("}"를 만나면) 갖고 있던 모든 값 소멸 
힙: FIFO, 터널 형식, 코드 블록이 끝나도 값이 소멸하지 않음. CLR(가비지 컬렉터)가 따로 관리함


-참조 형식을 사용하는 이유
코드블록이 끝난 뒤에 소멸하는 값 형식과 달리, 참조 형식은 값이 소멸하지 않기 때문에 유지가 필요한 데이터를 관리하는 데에 용이함


-값 형식을 사용하는 이유
코드블록이 끝난 뒤에 값이 소멸하기 때문에, 오래 사용하지 않고 금방 제거돼도 되는 인스턴스를 관리하는 데에 용이함 
즉 기본적으로 프로그램의 속도 저하를 방지한다!
클래스, 구조체 둘중 뭐를 사용해야 하지? 할 때의 기준이 될 수 있다


-복합 데이터 형식 객체 생성
객체: 틀로 구워진 붕어빵, 데이터를 담을 수 있고 기능을 사용할 수 있는 실체(instance)
"." 연산자를 사용해 객체의 필드 및 메소드에 접근
1) 클래스 객체 생성
클래스: 객체의 청사진, 틀(붕어빵 틀)
new 연산자로 객체 생성, 생성자 메소드로 초기화
객체의 필드 값 갱신 혹은 값 접근은 메소드를 거칠 것
2) 구조체 객체 생성
구조체: 객체의 데이터 형식
선언과 동시에 객체 생성, "." 연산자로 객체를 구성하는 필드 값 초기화 혹은 값 갱신해도 됨, 데이터 형식이니까
생성자 메소드를 사용해 값 초기화를 원할 경우 new 연산자를 사용(즉, 매개변수가 없는 생성자 함수는 사용이 불가능하다)


-구조체 vs 클래스
둘이 사용방식은 비슷하나 존재 이유가 다르다.
클래스: 객체를 추상화 하기 위함 / 참조 형식
구조체: 데이터를 담기 위한 데이터 형식(그래서 public으로 선언해서 사용하는 경우가 대다수) / 값 형식


-기본 데이터 형식 객체 생성
선언과 동시에 객체 생성. "." 연산자로 객체를 구성하는 필드 값이나 메소드에 접근, 갱신


-----


-객체 지향 프로그래밍의 3대 특성
은닉성(캡슐화): 필요한 최소의 기능만 노출시키고, 나머지 기능은 감춘다. 보안과 중요한 데이터의 값이 멋대로 변하는 것을 방지. (public, private, 등)
상속성:
다형성: 객체가 여러 형태를 가질 수 있다. 클래스의 상속 개념을 통해 실현한다.(오버라이딩) 
(+)다형성의 개념
다형성이라고 하면 어려울 것 같지만 아래같이 생각하면 쉬울 것이다.
*interface: 동물
*method: 먹는다, 걷는다, 잔다
*인터페이스 구현 클래스: 고양이, 원숭이, 병아리
동물들은 모두 먹고, 걷는다. 
하지만 동물들마다 먹고 걷는 방식은 다르다.
구현 클래스에서는 동물 각각이 먹고 걷는 방식을 구현한다.
같은 '먹는다'라는 동사에서, 동물마다 여러가지 형태로 구현할 수 있기때문에 이름이 다형성.


-오버로딩(Overloading)
동일 이름의 메소드가 매개변수의 구성(개수, 데이터 형식)에 따라 각기 독립적으로 다른 메소드가 될 수 있는 것
-> 오버로딩된 메소드가 많을 경우, virtual 키워드(가상함수)를 통해 해결할 수 있음


-오버라이딩(Overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스가 재정의하여 사용하는 행위 -> 상속을 통해 다형성 실현
public 메소드만 오버라이딩 가능하다.
자식 클래스가
1. 일반 클래스(부모)의 virtual 메소드 구현 시 (이때 가상메소드는 private 키워드를 붙이면 안 됨)
2. 추상 클래스(부모)의 abstract 메소드 구현 시 (이때 추상메소드는 private 키워드를 붙이면 안 됨)
3. 클래스의 override 메소드 구현 시(이때 private 키워드를 붙이면 안 됨) ->자식이 오버라이딩한 것을 자식의 자식이 오버라이딩하는 것
override 키워드를 앞에 붙여야 한다.


-상속
sealed 키워드가 없는 클래스를 부모 클래스로 지정한 클래스는 
해당 부모의 자식이 되어 private 키워드가 아닌 부모의 필드와 메소드를 받아와서 사용할 수 있다
또한, 부모의 메소드를 받아와서 자식에게 필요한 기능을 추가하여 이름만 같은, 완전히 다른 기능을 하는 메소드를 정의 가능하다(Override)
다만 virtual 키워드가 명시된 부모의 메소드만, 자식은 override 키워드를 명시한 메소드를 이용해 동일한 이름으로 재정의 가능하다
자식이 재정의한 이 메소드에 sealed 키워드를 붙일 경우, 이 자식을 부모로 삼은 자식 클래스(부모0세대, 본인1세대, 본인의 자식 2세대)는 해당 메소드를 override 할 수 없다


-sealed 키워드
1) 메소드에서
위의 마지막 줄 같은 상황에서, 자식의 자식의 자식이... 메소드를 계속해서 오버라이딩하다가 혹여 오류가 발생할 수 있음
이 오류가 상속으로 인해 복합적으로 덩어리지지 않도록, 사전에 오류의 크기를 제어하기 위한 방지턱 역할을 함
2) 클래스에서


-확장메소드
static 메소드 중 하나의 종류로, 기존 클래스의 기능을 확장하는 특수한 메소드. (확장메소드를 포함한 클래스는 무조건 static 클래스이다)
선언 방식은 기존 메소드와 동일하되, 첫번째 매개변수는 무조건 "this 자료형식(=이미 정의된 클래스) 매개변수명" 이다. 이 매개변수가 곧 이 확장메소드를 호출하는 객체를 뜻한다.
ex) 확장메소드의 매개변수 형식이 this int a 이면, 이 확장메소드는 int 클래스 객체만 호출할 수 있다.
두번째 매개변수부터는 여타 메소드와 동일하고, 선택적이다.
최상단에 "using 해당 확장메소드가 정의된 namespace;" 를 선언해야 메소드 사용이 가능하다.
일반 메소드보다 우선순위가 낮다. (동일 namespace 내에 이름, 매개변수가 동일한 일반 메소드가 존재할 경우)


-오버라이딩(Override) vs 확장메소드
메소드 오버라이딩은 상속의 개념의 연장선으로, virtual/abstract으로 선언된 메소드의 기존 기능 또는 본문이 없는 것을 스스로가 구현하여 다시금 해당 기능을 재정의하는 것을 말한다.
때문에, 부모 클래스와 자식(나) 클래스는 서로 이어져있으며 서로는 이러한 관계에 얽히게 된다. 
override된 메소드는 "나"(자식)가 소유한 기능, 그 외 virtual로 선언된 메소드를 override하지 않거나 virtual로 선언되어 있지 않은 메소드는 "부모"가 소유한 기능.

반면, 확장 메소드는 확장 메소드를 정의하는 static class와 확장할 대상과 아무런 관계도 없으며, 제 3자같은 느낌이 든다. 
(연예인과 팬 느낌, 둘은 엄연히 3자 관계)
확장 메소드는 범위내에서 외부에 공개되어 있는 기능들만으로 새로운 기능을 정의하는 것이 주 역할, 즉 기능을 확장하는 것이 주 역할. 
(많은 팬들(확장메소드)이 연예인(확장 당하는 대상)을 모방함(확장메소드의 구현)으로써 그의 인기(확장 당하는 대상의 기능)를 "확장"시킨단 느낌)


-인터페이스 VS 추상클래스(abstract)
우선 개념적으로 인터페이스는 추상클래스의 하위개념이다.
모든 메소드가 추상메소드 / 1개 이상의 메소드가 추상메소드
인터페이스는 아무것도 설계되지 않은채 밑그림만 있는 설계도, 추상클래스는 일부가 구현된 설계도라 비유할 수 있다.
특징적으로는 
1) 다중 상속 가능(인터페이스끼리도 가능)/불가능
2) 기본접근자가 public/private
3) 구현을 가지는 것이 불가능/가능
4) 인터페이스의 추상메소드를 구현하는 자식은 override 키워드를 안 써도 되지만, 
추상메소드를 구현하는 자식클래스는 해당 메소드 앞에 override 키워드를 꼭 써야 한다.
정도가 있다.

그렇다면 이 둘은 각자 언제 쓸까?

1. 인터페이스를 쓰는 경우
인터페이스를 설명하려면 다형성(Polymorphism)에 대한 개념이 등장한다.
동물이 먹고, 걷고, 자는 것은 공통적인데, 그 것을 행하는 방법이 각자 다르다.
고양이는 걸을 때 네발로 걷고, 원숭이는 두발 또는 네발로, 병아리도 두발로..
그래서 동물이 먹고, 걷고, 잔다는 틀만 만들어놓고
고양이, 원숭이, 병아리는 그 틀안에 자신만의 방법으로 메소드를 구현하는 것이다.
반드시 구현체 동물들은 먹고 걷고 자는방법이 구현되어야 한다. 동물이라면..
그리고 고양이의 자는법이 달라져도 원숭이, 병아리에게는 아무 영향도 없다.

2. 추상클래스를 쓰는 경우
야생고양이가 새끼를 낳았다. 새끼는 인간에 의해 집고양이가 되었다고하자.
어미고양이(부모클래스) - 야생고양이
{
  - 자는법 (메소드) 
  - 집에서 사는법 (추상화 메소드)
}
새끼고양이(자식클래스) - 집고양이
{
  - 자는법 (메소드)
  - 집에서 사는법 (메소드)
}
어미고양이는 야생고양이므로, 
집에서 사는법은 모르지만, 새끼고양이는 집에서 사는법을 알려주기 위해 추상화 메소드로 만들었다.(구현X)
어미고양이는 자는법이 있었고, 자식에게 전수하였다.
그러나 자식은 집고양이라 어미고양이와 자는법이 달랐다.
그래서 자식고양이 나름대로 자는법을 새로 터득하였다.
그게 이미 구현되어있는 부모클래스의 내용을 Override를 하는 것이다.
새끼고양이는 집 생활을 하며, 어미고양이가 모르는, 집에 사는법을 더 많이 터득하였다.
(부모 클래스보다 더 많이 구현되는 경우가 대부분이다)
결론은,
인터페이스는 다형성이라 생각하면되고, 추상클래스는 상속의 부모 - 자식 관계.. 
부모가 갖고있는 기능을 유전 받으면서, 기능을 더 추가한다거나, 부모의 유전된 기능을 약간 수정할 때 쓴다.
출처: https://marobiana.tistory.com/58 [Take Action]


-추상클래스 VS (가상메소드를 포함한)일반클래스
공통점
자식클래스에서 상속받아 재정의 시 override 키워드를 추가해야 함
차이점
추상클래스 내 추상메소드는 구현을 갖지 못하고, 일반클래스 내 가상메소드는 구현을 가질 수 있다
즉 추상메소드는 자식클래스가 "반드시" 구현해야 하지만, 가상메소드는 "선택적"으로 구현하면 된다


-static 한정자를 사용하는 이유
프로그램 전반에 걸쳐 사용하는 데이터, 메소드, 혹은 클래스를 사용하기 편리하게 한다.
해당 데이터나 메소드를 갖고 있는 클래스의 인스턴스를 따로 선언한 뒤, 해당 인스턴스를 매개체로 사용하는 수고로운 일을 할 필요가 없게 하기 때문이다.
그래서 static 클래스의 경우 이를 구성하는 필드, 메소드가 모두 static이어야 하며, (인스턴스를 따로 선언할 필요가 없으므로) 인스턴스를 생성할 수 없다. 인스턴스를 생성할 수 없으므로 생성자 메소드도 정의할 수 없다.
또한 상속을 받을 수 없다.


-얕은 복사 vs 깊은 복사
참조 형식 데이터 형식에서만 구별되는 개념
얕은 복사: 스택 단위에서 발생하는 복사이다.
참조 형식의 데이터 형식 인스턴스 간에 얕은 복사가 발생할 경우, 복사 당하는 인스턴스의 필드 값이 아닌, 인스턴스의 주소가 복사된다. 
즉, 복사한 인스턴스와 복사 당한 인스턴스가 동일한 힙 메모리 주소를 가리키고 있게 된다.
(값 형식 데이터 형식의 경우, 어차피 스택 단에 값을 저장하기 때문에, 스택 단에서 발생하는 복사가 곧 값 복사가 된다. 즉 얕은 복사==깊은 복사가 된다.)
깊은 복사: 힙 단위에서 발생하는 복사이다. C#의 경우 직접 구현해야 하는 기능.

