# C# 기술면접 대비 정리


### C#의 특징   
1. 객체지향 언어 (↔ 절차지향 언어)   
2. 컴파일 방식 (↔ 인터프리터 방식)   
  둘 다 작성한 코드를 기계어로 번역하는(바꿔주는) 기능은 같은데,   
  간단히 말하면 모아서 한방에 하느냐(Compiled), 한 줄씩 하느냐(Interpreted)의 차이가 있다.   
3. Managed 컴파일 방식(↔ Unmanaged 컴파일 방식)   
  컴파일 시 Unmanaged 컴파일 방식은 기계어로 바로 컴파일하지만,   
  Managed 컴파일 방식은 IL(Intermediate Language, 중간 언어)로 한번 컴파일 한 후,   
  CLR(Common Language Runtime)을 거쳐서 기계어로 번역한다.   
4. Strongly-typed(강한 타입화) 언어 (↔ Weakly typed(약한 타입화))   
  변수가 모든 Type(타입)의 값을 가질 수 있도록 설계됨 → Weekly typed   
  변수를 만들 때 어떤 타입으로 할 지 지정해야 함 → Strongly typed   
  단, 약한 타입화가 가진 데이터 형식 선언 생략의 편이함을 지원하고자 **var** 키워드를 지원한다.   
5. Managed 환경   
  CLR이 메모리 관리(GC)를 자동으로 수행한다.   
[출처](https://fiftiesstudy.tistory.com/270?category=937344)   


### .NET과 C#의 관계
![image](https://user-images.githubusercontent.com/40621689/160273264-abfc80ac-8c8f-4169-a2a2-c0ff6d3fca43.png)   
[출처](https://lineho.tistory.com/34)   


### C#의 컴파일 과정
소스코드(C#) → (compiler) → IL(Intermediate language)중간언어 → (CLR) → 기계어   
   
(+) IL 존재 이유   
.NET Framework 환경에서 개발할 수 있는 언어는 C# 말고도 다양한데(Visual basic, C++, ...),   
이들은 모두 각자의 컴파일러로 컴파일되지만, 컴파일된 결과를 IL로 통일함으로써   
애플리케이션의 개발과 실행 시 언어에 종속적이지 않은 플랫폼 제공이 가능해진다.   


### CLR(Common Language Runtime)
마이크로소프트의 CLI(Common Language Infrastructure)를 따르는 .NET Framework의 VM(가상머신)이다.   
두 가지 역할을 수행하는데,   
1. IL을 JIT 컴파일러를 사용해 컴파일하여 OS위에 있는 .NET Framework에서 작동하게 해주는 역할을 한다.   
2. GC(Garbage Collection)을 수행한다.   
(+) JIT VS AOT VS 인터프리터   
JIT(Just in time)는 프로그램 실행시점에 소소코드를 번역한다. 즉 초기 실행 속도가 느리다. 또한 번역한 정보를 메모리에 올려야 하기 때문에 메모리를 많이 먹는다.   
AOT(Ahead of time)는 실행 전 미리 소스코드를 번역한다. 번역을 따로 파일로 저장하기 때문에 HDD 용량을 많이 먹는다. 하지만 프로그램 실행시점엔 빠르다.   
인터프리터는 프로그램 실행할 때마다 한줄씩 소스코드를 번역한다. 속도가 느리지만 소스코드 변경시 즉시 실행이 가능하다.   


### C++ VS C#
1. C++은 컴파일러가 바로 기계어로 번역, 반면 C#은 중간언어로 번역 후 CLR이 기계어로 번역   
2. C++의 GC는 수동, C#은 자동   
3. C#에서는 모든 변수,메소드(main메소드도)가 클래스의 멤버로 속해야 하기 때문에, 전역변수나 전역함수 개념이 없음   


### 데이터 형식
복합 데이터 형식 VS 기본 데이터 형식으로 구성   
혹은 값 형식 VS 참조 형식으로 구성   
복합 데이터 형식, 기본 데이터 형식 모두 값 형식과 참조 형식 데이터들을 갖고 있음   
* 복합 데이터 형식   
  기본 데이터 형식을 부품 삼아 이들을 조립한, 즉 이들로 구성된 또 다른 데이터 형식   
  구조체, 클래스, 배열 등 (클래스는 참조형)   
  (구조체-값 형식, 클래스-참조 형식 그들의 생명주기가 다르므로 이에 따라 원하는 형식을 사용하면 될듯)   
* 기본 데이터 형식   
  숫자, 논리, string, object 등 (string, object는 참조형)   
   
||값 형식|참조 형식|
|:---:|:---:|:----:|
|저장 방식|데이터의 값|데이터의 주소|
|저장 위치|스택 메모리|힙 메모리|
|사용 이유|코드블록이 끝난 뒤에 값이 소멸하기 때문에, 오래 사용하지 않고 금방 제거돼도 되는 인스턴스를 관리하는 데에 용이함|참조 형식은 코드블록이 끝난 후에도 값이 소멸하지 않기 때문에 유지가 필요한 데이터를 관리하는 데에 용이함|


### 메모리영역
1. static   
  static 키워드가 붙은 전역변수들이 저장되는 공간. 프로그램 실행~종료 시까지 보존된다.
2. stack   
  값형식의 데이터 값이 저장되거나, 참조형식의 주소 값이 저장되는 공간. 함수 종료시 할당된 공간이 해제된다.
3. managed heap   
  참조형식의 주소를 따라갔을 때 실제 값이 저장되는 공간.   
  Garbage Collector가 자동으로 할당을 해제한다. 따라서 언제 할당이 해제되는지 알 수 없다.
[출처](https://guslabview.tistory.com/186)


### 박싱, 언박싱
* 박싱   
  참조 형식에 값 형식 데이터를 넣는 것이다   
  이렇게 되면 스택 메모리에 저장돼있던 값 형식 데이터가 힙 메모리로 옮겨가고, 스택 메모리에서는 해당 주소 값을 저장하게 된다.   
  (+) 참고로 기본 데이터 형식이자 값 형식인 **object** 데이터 형식은 모든 데이터 형식(값, 참조 형식 모두)을 받을 수 있다.   
  애초에 C#에서 모든 데이터 형식은 object 클래스의 상속을 받도록 지정해놨기 때문!   
* 언박싱   
  값 형식에 참조 형식 데이터를 넣는 것이다   
  스택 메모리에 힙 메모리에 들어있던 실제 값이 들어간다.   


### 얕은 복사 VS 깊은 복사
참조 형식 데이터 형식에서만 구별되는 개념   
* 얕은 복사   
  스택 단위에서 발생하는 복사이다.   
  참조 형식의 데이터 형식 인스턴스 간에 얕은 복사가 발생할 경우, 복사 당하는 인스턴스의 필드 값이 아닌, 인스턴스의 주소가 복사된다.   
  즉, 복사한 인스턴스와 복사 당한 인스턴스가 동일한 힙 메모리 주소를 가리키고 있게 된다.   
  (값 형식 데이터 형식의 경우, 어차피 스택 단에 값을 저장하기 때문에, 스택 단에서 발생하는 복사가 곧 값 복사가 된다.)   
  (즉 얕은 복사==깊은 복사가 된다.)   
* 깊은 복사   
  힙 단위에서 발생하는 복사이다. C#의 경우 직접 구현해야 하는 기능.   


### 복합 데이터 형식 객체 생성
객체: 틀로 구워진 붕어빵, 데이터를 담을 수 있고 기능을 사용할 수 있는 실체(instance)   
  "." 연산자를 사용해 객체의 필드 및 메소드에 접근   
1. 클래스 객체 생성   
  클래스: 객체의 청사진, 틀(붕어빵 틀)   
  new 연산자로 객체 생성, 생성자 메소드로 초기화   
  객체의 필드 값 갱신 혹은 값 접근은 메소드를 거칠 것   
2. 구조체 객체 생성
  구조체: 객체의 데이터 형식   
  선언과 동시에 객체 생성, "." 연산자로 객체를 구성하는 필드 값 초기화 혹은 값 갱신해도 됨, 데이터 형식이니까   
  생성자 메소드를 사용해 값 초기화를 원할 경우 new 연산자를 사용(즉, 매개변수가 없는 생성자 함수는 사용이 불가능하다)   


### 구조체 VS 클래스
||구조체|클래스|
|:---:|:---:|:---:|
|공통점|메소드를 가질 수 있다. 인터페이스를 상속받을 수 있다.|
|차이점|상속 불가|상속가능|
||생성자 불가능|생성자 가능|
|목적|데이터를 담기 위한 데이터 형식|객체를 추상화하기 위함|

단, 구조체가 구현한 인터페이스 객체로 구조체 객체에 접근할 시, 박싱이 일어난다.   
그러면 구조체 객체의 값을 의도처럼 직접 조작할 수 없으므로 주의해야함   
[참고](https://www.csharpstudy.com/Mistake/Article/10)


### 구조체 VS 튜플
튜플도 구조체의 한 종류이나, 구조체보다 추상화된 구조체라고 생각하면 좋다.   
형식의 이름을 갖지 않기 때문(단순히 .Item1, .Item2, ... 이런식으로 접근)   
임시적으로 사용할 복합 데이터 형식을 선언할 때 적합하다   


### 중첩클래스, 분할클래스
* 중첩클래스   
  클래스 안에 클래스를 선언하는 것
  겉 클래스의 private 데이터에도 접근이 가능하다! 그래서 은닉성을 위반함..!   
  외부에 노출시키고 싶지 않은 형식을 지정할 때 사용할 수 있다.   
* 분할클래스   
  partial 키워드가 붙은 클래스   
  클래스의 덩어리가 너무 커졌을 때, 이를 분할하기 위함   
  ```
  public class A
  {
    public void Method1(){}
    public void Method2(){}
    public void Method3(){}
    public void Method4(){}
  }
  를
  
  partial class A
  {
    public void Method1(){}
    public void Method2(){}
  }
  partial class A
  {
    public void Method3(){}
    public void Method4(){}
  }
  이렇게 2개로 나누는 것이다
  ```

### 지역변수 VS 전역변수
지역변수는 함수가 살아있는 동안에만 유효하기 때문에, 함수가 종료되면 지역변수도 소멸된다   
반면 전역변수는 프로그램이 살아있는동안 유효하므로, 프로그램이 종료되기 전까지 소멸되지 않는다   
지역변수가 전역변수보다 우선순위가 높음   
그래서 함수 내에서 동일한 이름을 가진 지역변수, 전역변수가 존재할 경우 지역변수를 따라간다   
ex) 함수의 매개변수가 전역변수와 이름이 동일할 경우 매개변수의 값을 먼저 따라감   


-----


### 객체 지향 프로그래밍
객체 간의 상호작용 방식으로 프로그램을 구성한 것이다.   
객체란, 현실 객체들에게서 공통적인 기능과 상태를 뽑아내는 추상화(의미있는 추출) 과정을 통해 만들어진 소프트웨어적인 객체를 의미한다.


### 객체의 구성
속성(상태): 필드, 변수, 데이터   
기능: 메소드   
   
   
### 객체 지향 프로그래밍의 3대 특성
1. 상속성   
  하위 개념이 상위 개념의 특성과 기능을 물려받는 것이다. 객체 지향 프로그래밍의 가장 핵심적인 특징이다.   
  코드의 재사용성을 줄임으로써 생산성과 가독성을 높인다.   
2. 은닉성(캡슐화)   
  필요한 최소의 기능만 노출시키고, 나머지 기능은 캡슐로 감춘다. 
  또한 데이터에 접근할 때는 직접 접근이 아닌 반드시 함수를 통해 접근해야 한다.   
  (ex: public, private, get함수, set함수 등)   
  (+)이유    
  프로그램 소스를 클래스 단위로 바라보게 됨으로써 좀더 복잡하고 커다란 소스코드도 쉽게 이해하게 된다.    
  소스의 보안과 더불어 중요한 데이터의 값이 멋대로 변하는 것을 방지한다.    
3. 다형성
  오버라이딩을 통해 자식 클래스는 부모 클래스와 다른 여러 형태를 가질 수 있다.   
  (+)다형성의 개념   
  다형성이라고 하면 어려울 것 같지만 아래같이 생각하면 쉬울 것이다.   
  * interface: 동물   
  * method: 먹는다, 걷는다, 잔다   
  * 인터페이스 구현 클래스: 고양이, 원숭이, 병아리   
  동물들은 모두 먹고, 걷는다.   
  하지만 동물들마다 먹고 걷는 방식은 다르다.   
  구현 클래스에서는 동물 각각이 먹고 걷는 방식을 구현한다.   
  같은 '먹는다'라는 동사에서, 동물마다 여러가지 형태로 구현할 수 있기때문에 이름이 다형성.   


### 오버로딩(Overloading)
동일 이름의 메소드가 매개변수의 구성(개수, 데이터 형식)에 따라 각기 독립적으로 다른 메소드가 될 수 있는 것   
→ 오버로딩된 메소드가 많을 경우, virtual 키워드(가상함수)를 통해 해결할 수 있음   


### 오버라이딩(Overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스가 재정의하여 사용하는 행위 → 상속을 통해 다형성 실현   
public 메소드만 오버라이딩 가능하다.   
자식 클래스가 아래 3가지 사항 중 하나에 해당될 경우   
  1. 일반 클래스(부모)의 virtual 메소드 구현 시 (이때 가상메소드는 private 키워드를 붙이면 안 됨)   
  2. 추상 클래스(부모)의 abstract 메소드 구현 시 (이때 추상메소드는 private 키워드를 붙이면 안 됨)   
  3. 부모클래스의 override 메소드 구현 시(이때 private 키워드를 붙이면 안 됨) ->자식이 오버라이딩한 것을 자식의 자식이 오버라이딩하는 것   
override 키워드를 앞에 붙여야 한다.   


### 상속
* sealed 키워드가 없는 클래스를 부모로 지정한 클래스는 해당 부모의 자식이 되어 private 키워드가 아닌 부모의 필드와 메소드를 받아와서 사용할 수 있다   
* 또한, 부모의 메소드를 받아와서 자식에게 필요한 기능을 추가하여 이름만 같은, 완전히 다른 기능을 하는 메소드를 정의 가능하다(override)   
  다만 virtual 키워드가 명시된 부모의 메소드만, 자식은 override 키워드를 명시한 메소드를 이용해 동일한 이름으로 재정의 가능하다   
* 자식이 재정의한 이 메소드에 sealed 키워드를 붙일 경우,   
  이 자식을 부모로 삼은 자식 클래스(부모0세대, 본인1세대, 본인의 자식 2세대)는 해당 메소드를 override 할 수 없다   


### virtual 키워드
[참고](https://zprooo915.tistory.com/11)   
(abstract VS virtual VS interface)   


### 인터페이스 VS 추상클래스(abstract)
우선 개념적으로 인터페이스는 추상클래스의 하위개념이다.   
||인터페이스|추상클래스|
|:-:|:--------:|:--------:|
|추상메소드 비율|모든 메소드|1개 이상 메소드|
|정의|아무것도 설계되지 않은채 밑그림만 있는 설계도|일부가 구현된 설계도|
|다중 상속 가능 여부|가능(인터페이스-클래스, 인터페이스-인터페이스 모두)|불가능|
|기본접근자|public|private|
|구현을 가지는 것|불가능|가능|
|자식 클래스가 override키워드를|안 써도 됨(모든 메소드가 추상메소드라)|꼭 써야 함|   

그렇다면 이 둘은 각자 언제 쓸까?   
1. 인터페이스를 쓰는 경우   
  인터페이스를 설명하려면 다형성(Polymorphism)에 대한 개념이 등장한다.   
  동물이 먹고, 걷고, 자는 것은 공통적인데, 그 것을 행하는 방법이 각자 다르다.   
  고양이는 걸을 때 네발로 걷고, 원숭이는 두발 또는 네발로, 병아리도 두발로..   
  그래서 동물이 먹고, 걷고, 잔다는 틀만 만들어놓고   
  고양이, 원숭이, 병아리는 그 틀안에 자신만의 방법으로 메소드를 구현하는 것이다.   
  반드시 구현체 동물들은 먹고 걷고 자는방법이 구현되어야 한다. 동물이라면..   
  그리고 고양이의 자는법이 달라져도 원숭이, 병아리에게는 아무 영향도 없다.   
2. 추상클래스를 쓰는 경우   
  야생고양이가 새끼를 낳았다. 새끼는 인간에 의해 집고양이가 되었다고하자.   
  ```
  어미고양이(부모클래스) - 야생고양이   
  {   
    - 자는법 (메소드)   
    - 집에서 사는법 (추상화 메소드)
  }
  ```   
  ```
  새끼고양이(자식클래스) - 집고양이
  {
    - 자는법 (메소드)
    - 집에서 사는법 (메소드)
  }
  ```   
  어미고양이는 야생고양이므로 집에서 사는법은 모르지만,   
  새끼고양이에게 집에서 사는법을 알려주기 위해 추상화 메소드로 만들었다.(단 모르니까 구현은 X)   
  어미고양이는 자는법이 있었고, 자식에게 전수하였다.   
  그러나 자식은 집고양이라 어미고양이와 자는법이 달랐다.   
  그래서 자식고양이 나름대로 자는법을 새로 터득하였다.   
  그게 이미 구현되어있는 부모클래스의 내용을 Override를 하는 것이다.   
  새끼고양이는 집 생활을 하며, 어미고양이가 모르는, 집에 사는법을 더 많이 터득하였다.   
  (부모 클래스보다 더 많이 구현되는 경우가 대부분이다)   
   
결론은,   
인터페이스는 다형성이라 생각하면되고,   
추상클래스는 상속의 부모 - 자식 관계..   
부모가 갖고있는 기능을 유전 받으면서, 기능을 더 추가한다거나, 부모의 유전된 기능을 약간 수정할 때 쓴다.   
[출처](https://marobiana.tistory.com/58)


### 추상클래스 VS (가상메소드를 포함한)일반클래스
* 공통점   
  자식클래스에서 상속받아 재정의 시 override 키워드를 추가해야 함   
* 차이점   
  추상클래스 내 추상메소드는 구현을 갖지 못하고, 일반클래스 내 가상메소드는 구현을 가질 수 있다   
   
즉, 추상메소드는 자식클래스가 "반드시" 구현해야 하지만, 가상메소드는 "선택적"으로 구현하면 된다   


### sealed 키워드
상속으로부터 봉인!   
클래스에 sealed 키워드가 포함된 메소드가 있는 경우 상속은 가능하지만(sealed된 메소드만 상속 불가)   
sealed 키워드가 클래스에 붙을 경우 상속 자체가 안 된다   
* 사용 이유   
  위 상속 설명의 마지막 줄 같은 상황에서, 자식의 자식의 자식이... 메소드를 계속해서 오버라이딩하다가 혹여 오류가 발생할 수 있음   
  이 오류가 상속으로 인해 복합적으로 덩어리지지 않도록, 사전에 오류의 크기를 제어하기 위한 방지턱 역할을 함   
  반복적인 상속으로 인해 클래스 설계가 지나치게 복잡해지지 않도록 방지하는 역할을 하기도 함   


### static 키워드 (정적)
모든 객체가 공통되게 사용하는 일정한 값이나 설정 정보같은 공용자원에 대해,   
매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해서 접근하기 위해 사용함    
인스턴스 생성 없이 바로 사용가능 하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리 할 때 이용한다.   
(new 명령어로 인스턴스를 생성하지 않고, Class명.메소드명 / Class명.변수명 이런식으로 접근)   
   
프로그램이 실행하기 전에 static 함수나 static 변수를 첫 단계로 메모리에 올려 프로그램을 실행시킴 (static이 실행시 1순위)   
또한 static 메소드, 클래스, 변수는 프로그램이 종료될 때까지 사라지지 않는다   

* 클래스, 메소드, 변수는 모두 static 키워드를 가질 수 있다   
  static 클래스의 경우 모든 클래스 멤버가 static 멤버로 되어 있음   
  static 메소드와 클래스는 상속(override)할 수 없음   
  static 클래스는 public 생성자(constructor)를 가질 수 없음(static 클래스는 객체를 생성할 수 없으므로)   
  대신 static 기본생성자를 가질 수 있다.(public 클래스명()이 아닌 static 클래스명()이러한 형식을 따른다. 매개변수를 가질 수 없음)   
  이는 주로 static 필드들을 초기화 하는데 사용한다. 따로 호출할 수 없고, 프로그램이 시작될 때 최초로 1번 자동으로 실행된다.   
   
* main함수가 static 키워드를 가진 이유   
main함수가 실행되기 위해서는 메모리에 미리 올라가야함   
(시작점인 main() 메소드를 호출하려고 하는데 메모리에 main이 없으면 실행을 할 수가 없게 되기 때문)   
그래서 main 메소드는 누군가 호출하기 전에 미리 메모리에 있어야 하기 때문에 static을 붙이는 것   
   
* 유의사항   
1. 상속을 통한 다형성을 실현할 수 없다는 점,   
2. 프로그램이 종료될 때까지 소멸하지 않는다는 점, (메모리 문제가 발생할 수 있음)   
3. 멀티스레드 방식에서 한 스레드가 static 값을 변경하면 모든 스레드에 영향을 준다는 점   
등 때문에 신중하게 사용해야 함  


### 확장메소드
static 메소드 중 하나의 종류로, 기존 클래스의 기능을 확장하는 특수한 메소드.   
확장메소드를 포함한 클래스는 무조건 static 클래스이다   
* 선언 방식   
  기존 static 메소드와 동일하되, 첫번째 매개변수는 무조건 "this 자료형식(=이미 정의된 클래스) 매개변수명" 이다.   
  이 매개변수가 곧 이 확장메소드를 호출하는 객체를 뜻한다.   
  ```
  public static int plus(this int a, int b) 
  {
    return a+b; 
  }
  public static void Main()
  {
    int c=2, d=3; 
    c.plus(d);   
  }
  ```
  두번째 매개변수부터는 여타 메소드와 동일하고, 선택적이다.   
* 유의사항   
  매개 변수의 형식과 갯수까지 같을 경우 기존 정의된 메서드가 실행됨   
  확장 메서드의 우선 순위는 인스턴스 메서드보다 낮기 때문에 동일한 메서드 이름을 사용하는 것은 피해야 함   
  ```
  public static string ToString(this int input) 
  {
    return input.ToString() + "kk"; 
  }
  public static void Main()
  {
    int a=2; 
    a.ToString(); // 결과는 "2kk"가 아닌 "2"가 나온다.
  }
  ```
  기존메소드인 ToString()이 이미 존재하기 때문에 얘가 먼저 실행됨   
[](https://slaner.tistory.com/189)


### override vs 확장메소드
* 오버라이딩   
  메소드 오버라이딩은 상속의 연장선으로,   
  일반클래스의 virtual 메소드 → 선언된 메소드의 기존 기능을 재정의   
  추상클래스의 abstract 메소드 → 본문이 없는 기능을 구현하여 정의   
  때문에, 부모 클래스와 자식(나) 클래스는 서로 이어져있으며 서로는 이러한 관계에 얽히게 된다.   
  override된 메소드 → **나(자식)** 가 소유한 기능   
  그 외 virtual로 선언된 메소드를 override하지 않거나, virtual로 선언되어 있지 않은 메소드 → **부모** 가 소유한 기능   
* 확장 메소드   
  반면, 확장 메소드는 확장 메소드를 정의하는 static class와   
  확장할 대상(this 키워드가 붙은 자료형) 간에 아무런 관계도 없으며, 제 3자같은 느낌이 든다. (연예인과 팬 느낌)   
  확장 메소드는 기능을 확장하는 것이 주 역할.   
  많은 팬들(확장메소드)이 연예인(확장 당하는 대상)을 모방함(확장메소드의 구현)으로써 그의 인기(확장 당하는 대상의 기능)를 "확장"시킨단 느낌   


-----
### namespace
class를 구분해서 효율을 높이기 위해 만들어진 개념   
하나의 프로그램 안에 동일한 이름의 클래스는 존재할 수 없지만, namespace를 다르게 지정하면 동일한 이름의 클래스가 존재할 수 있다.   
using [namespace이름]; 형태로 사용하며, 이는 namespace에 포함된 모든 클래스를 사용하겠다는 의미이다.   


### using
1. namespace 참조시
2. IDispose 인터페이스에게 상속받은 클래스들(Dispose()를 갖고있음)을 특정 블록 안에서만 사용시 => 자원을 효율적으로 사용할 수 있음   
```
private void GetData()
{
    using (var reader = new StreamReader("src.txt"))
    { 
        string data = reader.ReadToEnd();
        Debug.WriteLine(data);
    }  // 여기서 Dispose() 호출됨

    // ...
    Debug.WriteLine("...");
}
```

### Array(배열) VS ArrayList VS List<>
||Array|ArrayList|List<>|
|:-:|:--------:|:--------:|:---:|
|용량|미리 지정해야 함|미리 지정할 필요없음|미리 지정할 필요없음|
|저장방식|스택 메모리에 연속적인 형태로 저장(검색이 빠름)|포인터로 주소 저장(데이터를 object형식으로 저장)|포인터로 주소 저장|
|단점|중간삽입/삭제가 번거롭다|경우에 따라 배열보다 검색 속도가 느릴 수 있음. object 타입이라 형식이 안전하지 않다|경우에 따라 배열보다 검색 속도가 느릴 수 있음|

[Array를 동적으로 사용하는 법](https://im-first-rate.tistory.com/124)   


### 다차원 배열 VS 가변 배열(Jagged array)   
* 다차원 배열   
  `int [,] a = new int[2,3];`   
* 가변 배열   
  ```
  int [][] a = new int[2][];
  a[0] = { 1, 2, 3, 4, 5 };
  a[1] = { 5, 4, 3 };
  ```   
* 2차원 가변 배열   
  ```
  int [][,] a = new int[2][,]
  {
    new int[,] { {1, 2}, {3, 4}, {5, 6} },
    new int[,] { {1, 2} }
  }
  ```


### delegate VS event 
* delegate   
  콜백 기능을 함(메소드의 매개변수로 값이 아닌 코드, 즉 메소드를 넘기고 싶을 때 사용)   
  참조 형식의 데이터 형식. 클래스처럼 인스턴스를 생성해야 함   
  클래스같은 녀석이므로 클래스 바깥에서 우선 선언되며, 동일한 리턴타입과 매개변수 조합을 가진 메소드만 저장할 수 있다.   
  ```
  namespace a
  {
    delegate int DelegateA(int a, int b);
    class aa
    {
      public int plus(int a, int b)
      {
        return a+b;
      }
      public int minus(int a, int b)
      {
        return a-b;
      }
      public static void print(int a, int b, DelegateA delegatee)
      {
        Console.WriteLine(delegatee(a, b));
      }
    }
    class Program
    {
      public static void Main()
      {
        aa a = new aa();
        DelegateA delegateA;
        delegateA = new DelegateA(aa.plus);
        delegateA += new DelegateA(aa.minus); // 이런식으로 여러 개 함수를 추가할 수도 있음. 
        aa.print(2, 1, delegateA); // plus, minus 함수가 순차적으로 실행됨 (delegate 체인)
      }
    }
  }
  ```
* event   
  delegate와 선언 및 사용 방식은 비슷하나, delegate는 콜백을 위한 목적이라면 event는 사건 발생을 알리는 목적이 크다.   
  송신자 클래스와 수신자 클래스를 나눠서 생각하면 이해하기 편하다.   
  

### Thread VS Task
C# 명령어에서는 Thread도 존재하고 Task도 존재함 둘의 차이가 무엇일까   
   
   
### var VS dynamic
var는 컴파일 시에 데이터 형식이 결정된다. 그래서 한 번 데이터 형식이 결정되면 변경할 수 없다.   
반면 dynamic은 런타임 시 데이터 형식이 결정된다. 그래서 데이터 형식을 자유롭게 바꿀 수 있다.   
```
dynamic a;
a = 1;
a = "kk";
```
가 가능하다.   


### const VS readonly
* 공통점   
  상수를 저장하는 변수에 사용한다.   
* 차이점  
  const는 초기화할 때만 값을 지정할 수 있고,   
  readonly는 초기화할 때랑, 생성자에서 값을 지정할 수 있다.   
   
   
-----    
# Unity


### 생명주기   
  유니티에는 사용자가 호출하지 않아도 호출되는 함수들이 있다. 그 함수의 호출 주기를 생명주기라 함.   
  [참고](https://itmining.tistory.com/47)   


### Coroutine   
1. 함수는 하나의 유니티 프레임에서 수행되는데(덩어리져있다고 생각하면 쉽다.)   
이는 함수가 한 프레임에 수행하기에 긴 로직 혹은 시간 경과와 함께하는 일련의 이벤트에는 사용할 수 없음을 뜻한다.(덩어리를 작게 쪼갤 수 없다는 뜻)   
이를 가능하게 해주는 것이 코루틴이다!   
2. 또한 Update문을 사용하면 원하든 원하지 않든 매 프레임마다 계속 반복적으로 실행되지만,   
Coroutine을 사용한다면   
2-1. 필요한 순간에만 반복하고 필요하지 않을 때에는 전혀 사용하지 않음으로써 자원관리를 효과적으로 할 수 있다.   
2-2. 그 밖에도 당장 실행되는게 아니라 일정 시간동안 멈춰있다가 그 뒤에 동작하게 하거나 특정 조건을 부여해서 코드가 실행되도록 할 수도 있다.   
   
(+) 코루틴은 쓰레드가 생성되는 멀티스레드 방식으로 느껴질 수 있다.   
하지만 코루틴은 싱글 스레드로 비동기 방식을 구현한다. 순차 처리로부터 동시성을 구현한다.   
![image](https://user-images.githubusercontent.com/40621689/160411798-80cb78c9-d2bd-4020-bcd4-6a232d952162.png)   

(+) 코루틴을 포함한 GameObject의 active가 꺼지면 돌던 코루틴 메소드는 정지되고, 다시 active가 켜져도 재실행되지 않는다.   

```
IEnumerator 함수명()
{
  yield return + 조건;
  [함수 내용]
  // 함수 내용에 반복문을 사용한다면 마치 Update문처럼 매 프레임마다 반복되게 할 수 있다. Update문은 따로 동작하면서도 말이다.
  // 업데이트문에 이런 반복문을 쓰게 되면 해당 반복이 끝날 때까지, 반복문 아래에 있는 코드들은 전혀 실행이 되지 않는다.
  // 그러나 코루틴에서 반복문을 사용하면 Update와는 별도로 동작하기 때문에 모든 스크립트가 정상적으로 동작하게 된다.
}
```
```
//매 프레임마다 점점 흐려지는 함수
IEnumerator Fade() 
{
    for (float f = 1f; f >= 0; f -= 0.1f) 
    {
        Color c = renderer.material.color;
        c.a = f;
        renderer.material.color = c;
        yield return null;
    }
}

void Update() 
{
    if (Input.GetKeyDown("f")) 
    {
        StartCoroutine("Fade");
        // StopCoroutine()도 존재한다.
    }
}
```
* IEnumerator   
  IEnumerable은 배열과 같은 복합 데이터 형식의 데이터를 하나씩 넘겨주는 역할을 한다.   
  IEnumerator는 Current라는 멤버변수와 MoveNext()라는 멤버함수를 가진다.   
  IEnumerator는 이를 사용해 IEnumerable로부터 MoveNext()로 데이터 하나씩 이동한다.(코드 한줄씩 이동이라 이해해도 됨)   
  코드 진행중 **yield return X 나 yield break를 마주친 지점이 IEnumerator.MoveNext() 함수가 중단되는 지점** 이다.   
  yield로 넘겨주는 값이 Current 멤버 변수에 할당된다.   
  [참고](https://www.slideshare.net/jungsoopark104/ienumerator)   
  [출처](http://la-stranger.blogspot.com/2013/09/3d.html)
  
  
* yield 명령어   
  호출자에게 컬렉션 데이타를 하나씩 리턴할 때 사용한다.   
  흔히 Enumerator(Iterator)라고 불리우는 이러한 기능은 집합적인 데이타셋으로부터 데이타를 하나씩 호출자에게 보내주는 역할을 한다.   
  1. yield return은 컬렉션 데이타를 하나씩 리턴하는데 사용되고,   
  2. yield break는 리턴을 중지하고 Iteration 루프를 빠져 나올 때 사용한다.   
  다음에 함수 호출 시 yield문 이후부터 시작된다는 특징이 있다.   
  유니티에서는 다음에 나올 값이 무엇인지 혹은 값이 더이상 없는지 를 가르쳐주는 키워드이다.   
  따라서 코드 진행중 yield return X 나 yield break를 마주친 지점이 **IEnumerator.MoveNext() 함수가 중단되는 지점**이다.   
  
  
* Coroutine 내에서 yield의 종류   
  1. yield return null: 다음 프레임에 실행 됨.   
  2. yield return new WaitForSeconds(float): 매개변수로 입력한 숫자에 해당하는 초만 큼 기다렸다가 실행됨.   
  3. yield return new WaitForSecondsRealtime(flaot): 매개변수로 입력한 숫자에 해당하는 초만큼 기다렸다가 실행됨.   
  4. yield return + new WaitForFixedUpdate / WaitForEndOfFrame 등...   
  5. yield break: 일정 조건을 만족했을 때 코루틴이 끝나길 원한다면 이걸 사용하면 된다.   
  (+)2번과 3번의 차이점   
    유니티에서 시간은 TimeScale을 사용해서 느리거나 빠르게 조절할 수 있는데,   
    이 값의 변화에 영향을 받는 것이 2번, 무관한 것이 3번이다.   
[출처](https://velog.io/@uchang903/UnityCoroutine%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%99%9C%EC%9A%A9)   
[출처](https://kotlinworld.com/214)   
[출처](https://coding-of-today.tistory.com/171#:~:text=%EC%9A%B0%EC%84%A0%2C%20%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%B4%20%EC%96%B4%EB%96%A4,%ED%95%98%EB%8A%94%20%EA%B2%83%EC%9D%B4%20%EB%A7%A4%EC%9A%B0%20%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B4%EB%8B%A4.)   


### Coroutine VS Invoke   
1. Coroutine은 매개변수를 가질 수 있지만 Invoke는 그렇지 않다.
2. 코루틴은 여러개의 엔트리 포인트를 두어 여러패턴으로 시간간격을 컨트롤 할 수 있다.  
원하는 함수를 일정 시간 후에 호출하거나 일정 시간마다 반복해서 호출하는 경우 Invoke를 사용하는 게 적합하다.  
3. Invoke는 함수를 문자열로 된 이름으로 찾아서 사용하고 있다. 이때 C#의 리플렉션 기능을 사용하는데, 직접 함수를 호출하는 것에 비해서 느림.   
4. 스크립트 비활성화시 둘다 실행을 유지하지만, 오브젝트 비활성화시 Coroutine은 실행을 멈추지만 Invoke는 실행을 유지함  
[출처](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=sabotduke&logNo=220827796587)  


### 쉐이더
  화면에 출력될 픽셀의 색상과 좌표를 계산하는 함수   
  렌더링 파이프라인을 따른다.   
  
### 렌더링 파이프라인   
  ![image](https://user-images.githubusercontent.com/40621689/164011432-0f740468-d2b6-4c18-a65e-a4296c15ae9e.png)   
  [출처](https://icechou.tistory.com/298)   
  1. 정점 쉐이더
    오브젝트의 각 정점(vertex)을 화면상 좌표로 변환하는 작업 수행   
    
  2. 
