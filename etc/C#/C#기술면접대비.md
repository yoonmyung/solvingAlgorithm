# C# 기술면접 대비 정리


### C#의 특징   
1. 객체지향 언어 (↔절차지향 언어)   
2. 컴파일 방식 (↔인터프리터 방식)   
  둘 다 작성한 코드를 기계어로 번역하는(바꿔주는) 기능은 같은데,   
  간단히 말하면 모아서 한방에 하느냐(Compiled), 한 줄씩 하느냐(Interpreted)의 차이가 있다.   
3. Managed 컴파일 방식(↔Unmanaged 컴파일 방식)   
  컴파일 시 Unmanaged 컴파일 방식은 기계어로 바로 컴파일하지만,   
  Managed 컴파일 방식은 IL(Intermediate Language, 중간 언어)로 한번 컴파일 한 후, CLR(Common Language Runtime)을 거쳐서 기계어로 번역한다.   
4. Strongly-typed(강한 타입화) 언어 (↔Weakly typed(약한 타입화))   
  변수가 모든 Type(타입)의 값을 가질 수 있도록 설계됨→Weekly typed   
  변수를 만들 때 어떤 타입으로 할 지 지정해야 함→Strongly typed   
[출처](https://fiftiesstudy.tistory.com/270?category=937344)
    

### CLR(Common Language Runtime)
.NET Framework의 VM(가상머신)이다.


### Unity와 C#의 관계


### .NET과 C#의 관계
![image](https://user-images.githubusercontent.com/40621689/160273264-abfc80ac-8c8f-4169-a2a2-c0ff6d3fca43.png)


### 객체 지향 프로그래밍
객체 간의 상호작용 방식으로 프로그램을 구성한 것이다.   
객체란, 현실 객체들에게서 공통적인 기능과 상태를 뽑아내는 추상화(의미있는 추출) 과정을 통해 만들어진 소프트웨어적인 객체를 의미한다.


### 객체의 구성
속성(상태): 필드, 변수, 데이터   
기능: 메소드   


### 데이터 형식
복합 데이터 형식 vs 기본 데이터 형식으로 구성   
혹은 값 형식 vs 참조 형식으로 구성   
복합 데이터 형식, 기본 데이터 형식 모두 값 형식과 참조 형식 데이터들을 갖고 있음   


### 복합 데이터 형식 vs 기본 데이터 형식
복합 데이터 형식: 기본 데이터 형식을 부품 삼아 이들을 조립한, 즉 이들로 구성된 또 다른 데이터 형식   
  구조체, 클래스, 배열 등 (클래스는 참조형)   
기본 데이터 형식: 숫자, 논리, 문자열, 오브젝트 등 (문자열, 오브젝트는 참조형)   


### 참조 형식을 사용하는 이유
코드블록이 끝난 뒤에 소멸하는 값 형식과 달리,   
참조 형식은 값이 소멸하지 않기 때문에 유지가 필요한 데이터를 관리하는 데에 용이함   


### 값 형식을 사용하는 이유
코드블록이 끝난 뒤에 값이 소멸하기 때문에, 오래 사용하지 않고 금방 제거돼도 되는 인스턴스를 관리하는 데에 용이함   
즉 기본적으로 프로그램의 속도 저하를 방지한다!   
클래스, 구조체 둘중 뭐를 사용해야 하지? 할 때의 기준이 될 수 있다   


### 스택 vs 힙
스택: LIFO, 쌓여있는 책 형식, 코드 블록이 끝나면("}"를 만나면) 갖고 있던 모든 값 소멸   
힙: FIFO, 터널 형식, 코드 블록이 끝나도 값이 소멸하지 않음. CLR(가비지 컬렉터)가 따로 관리함


### 얕은 복사 vs 깊은 복사
참조 형식 데이터 형식에서만 구별되는 개념   
얕은 복사: 스택 단위에서 발생하는 복사이다.   
  참조 형식의 데이터 형식 인스턴스 간에 얕은 복사가 발생할 경우, 복사 당하는 인스턴스의 필드 값이 아닌, 인스턴스의 주소가 복사된다.   
  즉, 복사한 인스턴스와 복사 당한 인스턴스가 동일한 힙 메모리 주소를 가리키고 있게 된다.   
  (값 형식 데이터 형식의 경우, 어차피 스택 단에 값을 저장하기 때문에, 스택 단에서 발생하는 복사가 곧 값 복사가 된다. 즉 얕은 복사==깊은 복사가 된다.)   
깊은 복사: 힙 단위에서 발생하는 복사이다. C#의 경우 직접 구현해야 하는 기능.   


### 복합 데이터 형식 객체 생성
객체: 틀로 구워진 붕어빵, 데이터를 담을 수 있고 기능을 사용할 수 있는 실체(instance)   
  "." 연산자를 사용해 객체의 필드 및 메소드에 접근   
1. 클래스 객체 생성   
  클래스: 객체의 청사진, 틀(붕어빵 틀)   
  new 연산자로 객체 생성, 생성자 메소드로 초기화   
  객체의 필드 값 갱신 혹은 값 접근은 메소드를 거칠 것   
2. 구조체 객체 생성
  구조체: 객체의 데이터 형식   
  선언과 동시에 객체 생성, "." 연산자로 객체를 구성하는 필드 값 초기화 혹은 값 갱신해도 됨, 데이터 형식이니까   
  생성자 메소드를 사용해 값 초기화를 원할 경우 new 연산자를 사용(즉, 매개변수가 없는 생성자 함수는 사용이 불가능하다)   


### 구조체 vs 클래스
둘이 사용방식은 비슷하나 존재 이유가 다르다.   
* 클래스
객체를 추상화 하기 위함    
참조 형식   
* 구조체
데이터를 담기 위한 데이터 형식(그래서 public으로 선언해서 사용하는 경우가 대다수)    
값 형식   


### 기본 데이터 형식 객체 생성
선언과 동시에 객체 생성. "." 연산자로 객체를 구성하는 필드 값이나 메소드에 접근, 갱신


### 지역변수 VS 전역변수
지역변수는 함수가 살아있는 동안에만 유효하기 때문에, 함수가 종료되면 지역변수도 소멸된다   
반면 전역변수는 프로그램이 살아있는동안 유효하므로, 프로그램이 종료되기 전까지 소멸되지 않는다   
지역변수가 전역변수보다 우선순위가 높음   
그래서 함수 내에서 동일한 이름을 가진 지역변수, 전역변수가 존재할 경우 지역변수를 따라간다   
ex) 함수의 매개변수가 전역변수와 이름이 동일할 경우 매개변수의 값을 먼저 따라감   


-----


### 객체 지향 프로그래밍의 3대 특성
1. 상속성   
  하위 개념이 상위 개념의 특성과 기능을 물려받는 것이다. 객체 지향 프로그래밍의 가장 핵심적인 특징이다.   
  코드의 재사용성을 줄임으로써 생산성과 가독성을 높인다.   
2. 은닉성(캡슐화)   
  필요한 최소의 기능만 노출시키고, 나머지 기능은 캡슐로 감춘다. 
  또한 데이터에 접근할 때는 직접 접근이 아닌 반드시 함수를 통해 접근해야 한다.   
  (ex: public, private, get함수, set함수 등)   
  (+)이유    
  프로그램 소스를 클래스 단위로 바라보게 됨으로써 좀더 복잡하고 커다란 소스코드도 쉽게 이해하게 된다.    
  소스의 보안과 더불어 중요한 데이터의 값이 멋대로 변하는 것을 방지한다.    
3. 다형성
  오버라이딩을 통해 자식 클래스는 부모 클래스와 다른 여러 형태를 가질 수 있다.   
  (+)다형성의 개념   
  다형성이라고 하면 어려울 것 같지만 아래같이 생각하면 쉬울 것이다.   
  * interface: 동물   
  * method: 먹는다, 걷는다, 잔다   
  * 인터페이스 구현 클래스: 고양이, 원숭이, 병아리   
  동물들은 모두 먹고, 걷는다.   
  하지만 동물들마다 먹고 걷는 방식은 다르다.   
  구현 클래스에서는 동물 각각이 먹고 걷는 방식을 구현한다.   
  같은 '먹는다'라는 동사에서, 동물마다 여러가지 형태로 구현할 수 있기때문에 이름이 다형성.   


### 오버로딩(Overloading)
동일 이름의 메소드가 매개변수의 구성(개수, 데이터 형식)에 따라 각기 독립적으로 다른 메소드가 될 수 있는 것   
→ 오버로딩된 메소드가 많을 경우, virtual 키워드(가상함수)를 통해 해결할 수 있음   


### 오버라이딩(Overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스가 재정의하여 사용하는 행위 → 상속을 통해 다형성 실현   
public 메소드만 오버라이딩 가능하다.   
자식 클래스가 아래 3가지 사항 중 하나에 해당될 경우   
  1. 일반 클래스(부모)의 virtual 메소드 구현 시 (이때 가상메소드는 private 키워드를 붙이면 안 됨)   
  2. 추상 클래스(부모)의 abstract 메소드 구현 시 (이때 추상메소드는 private 키워드를 붙이면 안 됨)   
  3. 부모클래스의 override 메소드 구현 시(이때 private 키워드를 붙이면 안 됨) ->자식이 오버라이딩한 것을 자식의 자식이 오버라이딩하는 것   
override 키워드를 앞에 붙여야 한다.   


### 상속
* sealed 키워드가 없는 클래스를 부모로 지정한 클래스는 해당 부모의 자식이 되어 private 키워드가 아닌 부모의 필드와 메소드를 받아와서 사용할 수 있다   
* 또한, 부모의 메소드를 받아와서 자식에게 필요한 기능을 추가하여 이름만 같은, 완전히 다른 기능을 하는 메소드를 정의 가능하다(override)   
  다만 virtual 키워드가 명시된 부모의 메소드만, 자식은 override 키워드를 명시한 메소드를 이용해 동일한 이름으로 재정의 가능하다   
* 자식이 재정의한 이 메소드에 sealed 키워드를 붙일 경우,   
  이 자식을 부모로 삼은 자식 클래스(부모0세대, 본인1세대, 본인의 자식 2세대)는 해당 메소드를 override 할 수 없다   


### virtual 키워드
[참고](https://zprooo915.tistory.com/11)   
(abstract VS virtual VS interface)   


### 인터페이스 VS 추상클래스(abstract)
우선 개념적으로 인터페이스는 추상클래스의 하위개념이다.   
||인터페이스|추상클래스|
|:-:|:--------:|:--------:|
|추상메소드 비율|모든 메소드|1개 이상 메소드|
|정의|아무것도 설계되지 않은채 밑그림만 있는 설계도|일부가 구현된 설계도|
|다중 상속 가능 여부|가능(인터페이스-클래스, 인터페이스-인터페이스 모두)|불가능|
|기본접근자|public|private|
|구현을 가지는 것|불가능|가능|
|자식 클래스가 override키워드를|안 써도 됨(모든 메소드가 추상메소드라)|꼭 써야 함|   

그렇다면 이 둘은 각자 언제 쓸까?   
1. 인터페이스를 쓰는 경우   
  인터페이스를 설명하려면 다형성(Polymorphism)에 대한 개념이 등장한다.   
  동물이 먹고, 걷고, 자는 것은 공통적인데, 그 것을 행하는 방법이 각자 다르다.   
  고양이는 걸을 때 네발로 걷고, 원숭이는 두발 또는 네발로, 병아리도 두발로..   
  그래서 동물이 먹고, 걷고, 잔다는 틀만 만들어놓고   
  고양이, 원숭이, 병아리는 그 틀안에 자신만의 방법으로 메소드를 구현하는 것이다.   
  반드시 구현체 동물들은 먹고 걷고 자는방법이 구현되어야 한다. 동물이라면..   
  그리고 고양이의 자는법이 달라져도 원숭이, 병아리에게는 아무 영향도 없다.   
2. 추상클래스를 쓰는 경우   
  야생고양이가 새끼를 낳았다. 새끼는 인간에 의해 집고양이가 되었다고하자.   
  ```
  어미고양이(부모클래스) - 야생고양이   
  {   
    - 자는법 (메소드)   
    - 집에서 사는법 (추상화 메소드)
  }
  ```   
  ```
  새끼고양이(자식클래스) - 집고양이
  {
    - 자는법 (메소드)
    - 집에서 사는법 (메소드)
  }
  ```   
  어미고양이는 야생고양이므로 집에서 사는법은 모르지만,   
  새끼고양이에게 집에서 사는법을 알려주기 위해 추상화 메소드로 만들었다.(단 모르니까 구현은 X)   
  어미고양이는 자는법이 있었고, 자식에게 전수하였다.   
  그러나 자식은 집고양이라 어미고양이와 자는법이 달랐다.   
  그래서 자식고양이 나름대로 자는법을 새로 터득하였다.   
  그게 이미 구현되어있는 부모클래스의 내용을 Override를 하는 것이다.   
  새끼고양이는 집 생활을 하며, 어미고양이가 모르는, 집에 사는법을 더 많이 터득하였다.   
  (부모 클래스보다 더 많이 구현되는 경우가 대부분이다)   
   
결론은,   
인터페이스는 다형성이라 생각하면되고,   
추상클래스는 상속의 부모 - 자식 관계..   
부모가 갖고있는 기능을 유전 받으면서, 기능을 더 추가한다거나, 부모의 유전된 기능을 약간 수정할 때 쓴다.   
[출처](https://marobiana.tistory.com/58)


### 추상클래스 VS (가상메소드를 포함한)일반클래스
* 공통점   
  자식클래스에서 상속받아 재정의 시 override 키워드를 추가해야 함   
* 차이점   
  추상클래스 내 추상메소드는 구현을 갖지 못하고, 일반클래스 내 가상메소드는 구현을 가질 수 있다   
   
즉, 추상메소드는 자식클래스가 "반드시" 구현해야 하지만, 가상메소드는 "선택적"으로 구현하면 된다   


### sealed 키워드
상속으로부터 봉인!   
클래스에 sealed 키워드가 포함된 메소드가 있는 경우 상속은 가능하지만(sealed된 메소드만 상속 불가)   
sealed 키워드가 클래스에 붙을 경우 상속 자체가 안 된다   
* 사용 이유   
  위 상속 설명의 마지막 줄 같은 상황에서, 자식의 자식의 자식이... 메소드를 계속해서 오버라이딩하다가 혹여 오류가 발생할 수 있음   
  이 오류가 상속으로 인해 복합적으로 덩어리지지 않도록, 사전에 오류의 크기를 제어하기 위한 방지턱 역할을 함   
  반복적인 상속으로 인해 클래스 설계가 지나치게 복잡해지지 않도록 방지하는 역할을 하기도 함   


### static 키워드 (정적)
모든 객체가 공통되게 사용하는 일정한 값이나 설정 정보같은 공용자원에 대해,   
매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해서 접근하기 위해 사용함    
인스턴스 생성 없이 바로 사용가능 하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리 할 때 이용한다.   
(new 명령어로 인스턴스를 생성하지 않고, Class명.메소드명 / Class명.변수명 이런식으로 접근)   
   
프로그램이 실행하기 전에 static 함수나 static 변수를 첫 단계로 메모리에 올려 프로그램을 실행시킴 (static이 실행시 1순위)   
또한 static 메소드, 클래스, 변수는 프로그램이 종료될 때까지 사라지지 않는다   

* 클래스, 메소드, 변수는 모두 static 키워드를 가질 수 있다   
  static 클래스의 경우 모든 클래스 멤버가 static 멤버로 되어 있음   
  static 메소드와 클래스는 상속(override)할 수 없음   
  static 클래스는 public 생성자(constructor)를 가질 수 없음(static 클래스는 객체를 생성할 수 없으므로)   
  대신 static 기본생성자를 가질 수 있다.(public 클래스명()이 아닌 static 클래스명()이러한 형식을 따른다. 매개변수를 가질 수 없음)   
  이는 주로 static 필드들을 초기화 하는데 사용한다. 따로 호출할 수 없고, 프로그램이 시작될 때 최초로 1번 자동으로 실행된다.   
   
* main함수가 static 키워드를 가진 이유   
main함수가 실행되기 위해서는 메모리에 미리 올라가야함   
(시작점인 main() 메소드를 호출하려고 하는데 메모리에 main이 없으면 실행을 할 수가 없게 되기 때문)   
그래서 main 메소드는 누군가 호출하기 전에 미리 메모리에 있어야 하기 때문에 static을 붙이는 것   
   
* 유의사항   
1. 상속을 통한 다형성을 실현할 수 없다는 점,   
2. 프로그램이 종료될 때까지 소멸하지 않는다는 점, (메모리 문제가 발생할 수 있음)   
3. 멀티스레드 방식에서 한 스레드가 static 값을 변경하면 모든 스레드에 영향을 준다는 점   
등 때문에 신중하게 사용해야 함  


### 확장메소드
static 메소드 중 하나의 종류로, 기존 클래스의 기능을 확장하는 특수한 메소드.   
확장메소드를 포함한 클래스는 무조건 static 클래스이다   
* 선언 방식   
  기존 static 메소드와 동일하되, 첫번째 매개변수는 무조건 "this 자료형식(=이미 정의된 클래스) 매개변수명" 이다.   
  이 매개변수가 곧 이 확장메소드를 호출하는 객체를 뜻한다.   
  ```
  public static int plus(this int a, int b) 
  {
    return a+b; 
  }
  public static void Main()
  {
    int c=2, d=3; 
    c.plus(d);   
  }
  ```
  두번째 매개변수부터는 여타 메소드와 동일하고, 선택적이다.   
* 유의사항   
  매개 변수의 형식과 갯수까지 같을 경우 기존 정의된 메서드가 실행됨   
  확장 메서드의 우선 순위는 인스턴스 메서드보다 낮기 때문에 동일한 메서드 이름을 사용하는 것은 피해야 함   
  ```
  public static string ToString(this int input) 
  {
    return input.ToString() + "kk"; 
  }
  public static void Main()
  {
    int a=2; 
    a.ToString(); // 결과는 "2kk"가 아닌 "2"가 나온다.
  }
  ```
  기존메소드인 ToString()이 이미 존재하기 때문에 얘가 먼저 실행됨   
[참고](https://slaner.tistory.com/189)


### override vs 확장메소드
* 오버라이딩   
  메소드 오버라이딩은 상속의 연장선으로,   
  일반클래스의 virtual 메소드 → 선언된 메소드의 기존 기능을 재정의   
  추상클래스의 abstract 메소드 → 본문이 없는 기능을 구현하여 정의   
  때문에, 부모 클래스와 자식(나) 클래스는 서로 이어져있으며 서로는 이러한 관계에 얽히게 된다.   
  override된 메소드 → **나(자식)** 가 소유한 기능   
  그 외 virtual로 선언된 메소드를 override하지 않거나, virtual로 선언되어 있지 않은 메소드 → **부모** 가 소유한 기능   
* 확장 메소드   
  반면, 확장 메소드는 확장 메소드를 정의하는 static class와   
  확장할 대상(this 키워드가 붙은 자료형) 간에 아무런 관계도 없으며, 제 3자같은 느낌이 든다. (연예인과 팬 느낌)   
  확장 메소드는 기능을 확장하는 것이 주 역할.   
  많은 팬들(확장메소드)이 연예인(확장 당하는 대상)을 모방함(확장메소드의 구현)으로써 그의 인기(확장 당하는 대상의 기능)를 "확장"시킨단 느낌   


-----
### namespace
쉽게 말해 class들을 정리하기 위해 만들어진 개념   


### linq   


### Thread VS Task   
   
   
-----    
    
    
    
# Unity


### Coroutine


### 실행 순서


