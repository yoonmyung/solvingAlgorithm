# C# 기술면접 대비 정리


### C#의 특징   
1. 객체지향 언어 (↔ 절차지향 언어)   
2. 컴파일 방식 (↔ 인터프리터 방식)   
  둘 다 작성한 코드를 기계어로 번역하는(바꿔주는) 기능은 같은데,   
  간단히 말하면 모아서 한방에 하느냐(Compiled), 한 줄씩 하느냐(Interpreted)의 차이가 있다.   
3. Managed 컴파일 방식(↔ Unmanaged 컴파일 방식)   
  컴파일 시 Unmanaged 컴파일 방식은 기계어로 바로 컴파일하지만,   
  Managed 컴파일 방식은 IL(Intermediate Language, 중간 언어)로 한번 컴파일 한 후,   
  CLR(Common Language Runtime)을 거쳐서 기계어로 번역한다.   
4. Strongly-typed(강한 타입화) 언어 (↔ Weakly typed(약한 타입화))   
  변수가 모든 Type(타입)의 값을 가질 수 있도록 설계됨 → Weekly typed   
  변수를 만들 때 어떤 타입으로 할 지 지정해야 함 → Strongly typed   
  단, 약한 타입화가 가진 데이터 형식 선언 생략의 편이함을 지원하고자 **var** 키워드를 지원한다.   
5. Managed 환경   
  CLR이 메모리 관리(GC)를 자동으로 수행한다.   
[출처](https://fiftiesstudy.tistory.com/270?category=937344)   


### .NET과 C#의 관계
![image](https://user-images.githubusercontent.com/40621689/160273264-abfc80ac-8c8f-4169-a2a2-c0ff6d3fca43.png)   
[출처](https://lineho.tistory.com/34)   


### C#의 컴파일 과정
소스코드(C#) → (compiler) → IL(Intermediate language)중간언어 → (CLR) → 기계어   
   
(+) IL 존재 이유   
.NET Framework 환경에서 개발할 수 있는 언어는 C# 말고도 다양한데(Visual basic, C++, ...),   
이들은 모두 각자의 컴파일러로 컴파일되지만, 컴파일된 결과를 IL로 통일함으로써   
애플리케이션의 개발과 실행 시 언어에 종속적이지 않은 플랫폼 제공이 가능해진다.   


### CLR(Common Language Runtime)
마이크로소프트의 CLI(Common Language Infrastructure)를 따르는 .NET Framework의 VM(가상머신)이다.   
두 가지 역할을 수행하는데,   
1. IL을 JIT 컴파일러를 사용해 컴파일하여 OS위에 있는 .NET Framework에서 작동하게 해주는 역할을 한다.   
2. GC(Garbage Collection)을 수행한다.   


### 데이터 형식
복합 데이터 형식 VS 기본 데이터 형식으로 구성   
혹은 값 형식 VS 참조 형식으로 구성   
복합 데이터 형식, 기본 데이터 형식 모두 값 형식과 참조 형식 데이터들을 갖고 있음   
* 복합 데이터 형식   
  기본 데이터 형식을 부품 삼아 이들을 조립한, 즉 이들로 구성된 또 다른 데이터 형식   
  구조체, 클래스, 배열 등 (클래스는 참조형)   
  (구조체-값 형식, 클래스-참조 형식 그들의 생명주기가 다르므로 이에 따라 원하는 형식을 사용하면 될듯)   
* 기본 데이터 형식   
  숫자, 논리, string, object 등 (string, object는 참조형)   
   
||값 형식|참조 형식|
|:---:|:---:|:----:|
|저장 방식|데이터의 값|데이터의 주소|
|저장 위치|스택 메모리|힙 메모리|
|사용 이유|코드블록이 끝난 뒤에 값이 소멸하기 때문에, 오래 사용하지 않고 금방 제거돼도 되는 인스턴스를 관리하는 데에 용이함|참조 형식은 코드블록이 끝난 후에도 값이 소멸하지 않기 때문에 유지가 필요한 데이터를 관리하는 데에 용이함|


### 메모리영역
1. static   
  static 키워드가 붙은 전역변수들이 저장되는 공간. 프로그램 실행~종료 시까지 보존된다.
2. stack   
  값형식의 데이터 값이 저장되거나, 참조형식의 주소 값이 저장되는 공간. 함수 종료시 할당된 공간이 해제된다.
3. managed heap   
  참조형식의 주소를 따라갔을 때 실제 값이 저장되는 공간.   
  Garbage Collector가 자동으로 할당을 해제한다. 따라서 언제 할당이 해제되는지 알 수 없다.
[출처](https://guslabview.tistory.com/186)


### 박싱, 언박싱
* 박싱   
  참조 형식에 값 형식 데이터를 넣는 것이다   
  이렇게 되면 스택 메모리에 저장돼있던 값 형식 데이터가 힙 메모리로 옮겨가고, 스택 메모리에서는 해당 주소 값을 저장하게 된다.   
  (+) 참고로 기본 데이터 형식이자 값 형식인 **object** 데이터 형식은 모든 데이터 형식(값, 참조 형식 모두)을 받을 수 있다.   
  애초에 C#에서 모든 데이터 형식은 object 클래스의 상속을 받도록 지정해놨기 때문!   
* 언박싱   
  값 형식에 참조 형식 데이터를 넣는 것이다   
  스택 메모리에 힙 메모리에 들어있던 실제 값이 들어간다.   


### 얕은 복사 VS 깊은 복사
참조 형식 데이터 형식에서만 구별되는 개념   
* 얕은 복사   
  스택 단위에서 발생하는 복사이다.   
  참조 형식의 데이터 형식 인스턴스 간에 얕은 복사가 발생할 경우, 복사 당하는 인스턴스의 필드 값이 아닌, 인스턴스의 주소가 복사된다.   
  즉, 복사한 인스턴스와 복사 당한 인스턴스가 동일한 힙 메모리 주소를 가리키고 있게 된다.   
  (값 형식 데이터 형식의 경우, 어차피 스택 단에 값을 저장하기 때문에, 스택 단에서 발생하는 복사가 곧 값 복사가 된다.)   
  (즉 얕은 복사==깊은 복사가 된다.)   
* 깊은 복사   
  힙 단위에서 발생하는 복사이다. C#의 경우 직접 구현해야 하는 기능.   


### 복합 데이터 형식 객체 생성
객체: 틀로 구워진 붕어빵, 데이터를 담을 수 있고 기능을 사용할 수 있는 실체(instance)   
  "." 연산자를 사용해 객체의 필드 및 메소드에 접근   
1. 클래스 객체 생성   
  클래스: 객체의 청사진, 틀(붕어빵 틀)   
  new 연산자로 객체 생성, 생성자 메소드로 초기화   
  객체의 필드 값 갱신 혹은 값 접근은 메소드를 거칠 것   
2. 구조체 객체 생성
  구조체: 객체의 데이터 형식   
  선언과 동시에 객체 생성, "." 연산자로 객체를 구성하는 필드 값 초기화 혹은 값 갱신해도 됨, 데이터 형식이니까   
  생성자 메소드를 사용해 값 초기화를 원할 경우 new 연산자를 사용(즉, 매개변수가 없는 생성자 함수는 사용이 불가능하다)   


### 구조체 VS 클래스
||구조체|클래스|
|:---:|:---:|:---:|
|공통점|메소드를 가질 수 있다. 인터페이스를 상속받을 수 있다.|
|차이점|상속 불가|상속가능|
||생성자 불가능|생성자 가능|
|목적|데이터를 담기 위한 데이터 형식|객체를 추상화하기 위함|

단, 구조체가 구현한 인터페이스 객체로 구조체 객체에 접근할 시, 박싱이 일어난다.   
그러면 구조체 객체의 값을 의도처럼 직접 조작할 수 없으므로 주의해야함   
[참고](https://www.csharpstudy.com/Mistake/Article/10)


### 구조체 VS 튜플
튜플도 구조체의 한 종류이나, 구조체보다 추상화된 구조체라고 생각하면 좋다.   
형식의 이름을 갖지 않기 때문(단순히 .Item1, .Item2, ... 이런식으로 접근)   
임시적으로 사용할 복합 데이터 형식을 선언할 때 적합하다   


### 중첩클래스, 분할클래스
* 중첩클래스   
  클래스 안에 클래스를 선언하는 것
  겉 클래스의 private 데이터에도 접근이 가능하다! 그래서 은닉성을 위반함..!   
  외부에 노출시키고 싶지 않은 형식을 지정할 때 사용할 수 있다.   
* 분할클래스   
  partial 키워드가 붙은 클래스   
  클래스의 덩어리가 너무 커졌을 때, 이를 분할하기 위함   
  ```
  public class A
  {
    public void Method1(){}
    public void Method2(){}
    public void Method3(){}
    public void Method4(){}
  }
  를
  
  partial class A
  {
    public void Method1(){}
    public void Method2(){}
  }
  partial class A
  {
    public void Method3(){}
    public void Method4(){}
  }
  이렇게 2개로 나누는 것이다
  ```

### 지역변수 VS 전역변수
지역변수는 함수가 살아있는 동안에만 유효하기 때문에, 함수가 종료되면 지역변수도 소멸된다   
반면 전역변수는 프로그램이 살아있는동안 유효하므로, 프로그램이 종료되기 전까지 소멸되지 않는다   
지역변수가 전역변수보다 우선순위가 높음   
그래서 함수 내에서 동일한 이름을 가진 지역변수, 전역변수가 존재할 경우 지역변수를 따라간다   
ex) 함수의 매개변수가 전역변수와 이름이 동일할 경우 매개변수의 값을 먼저 따라감   


-----


### 객체 지향 프로그래밍
객체 간의 상호작용 방식으로 프로그램을 구성한 것이다.   
객체란, 현실 객체들에게서 공통적인 기능과 상태를 뽑아내는 추상화(의미있는 추출) 과정을 통해 만들어진 소프트웨어적인 객체를 의미한다.


### 객체의 구성
속성(상태): 필드, 변수, 데이터   
기능: 메소드   
   
   
### 객체 지향 프로그래밍의 3대 특성
1. 상속성   
  하위 개념이 상위 개념의 특성과 기능을 물려받는 것이다. 객체 지향 프로그래밍의 가장 핵심적인 특징이다.   
  코드의 재사용성을 줄임으로써 생산성과 가독성을 높인다.   
2. 은닉성(캡슐화)   
  필요한 최소의 기능만 노출시키고, 나머지 기능은 캡슐로 감춘다. 
  또한 데이터에 접근할 때는 직접 접근이 아닌 반드시 함수를 통해 접근해야 한다.   
  (ex: public, private, get함수, set함수 등)   
  (+)이유    
  프로그램 소스를 클래스 단위로 바라보게 됨으로써 좀더 복잡하고 커다란 소스코드도 쉽게 이해하게 된다.    
  소스의 보안과 더불어 중요한 데이터의 값이 멋대로 변하는 것을 방지한다.    
3. 다형성
  오버라이딩을 통해 자식 클래스는 부모 클래스와 다른 여러 형태를 가질 수 있다.   
  (+)다형성의 개념   
  다형성이라고 하면 어려울 것 같지만 아래같이 생각하면 쉬울 것이다.   
  * interface: 동물   
  * method: 먹는다, 걷는다, 잔다   
  * 인터페이스 구현 클래스: 고양이, 원숭이, 병아리   
  동물들은 모두 먹고, 걷는다.   
  하지만 동물들마다 먹고 걷는 방식은 다르다.   
  구현 클래스에서는 동물 각각이 먹고 걷는 방식을 구현한다.   
  같은 '먹는다'라는 동사에서, 동물마다 여러가지 형태로 구현할 수 있기때문에 이름이 다형성.   


### 오버로딩(Overloading)
동일 이름의 메소드가 매개변수의 구성(개수, 데이터 형식)에 따라 각기 독립적으로 다른 메소드가 될 수 있는 것   
→ 오버로딩된 메소드가 많을 경우, virtual 키워드(가상함수)를 통해 해결할 수 있음   


### 오버라이딩(Overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스가 재정의하여 사용하는 행위 → 상속을 통해 다형성 실현   
public 메소드만 오버라이딩 가능하다.   
자식 클래스가 아래 3가지 사항 중 하나에 해당될 경우   
  1. 일반 클래스(부모)의 virtual 메소드 구현 시 (이때 가상메소드는 private 키워드를 붙이면 안 됨)   
  2. 추상 클래스(부모)의 abstract 메소드 구현 시 (이때 추상메소드는 private 키워드를 붙이면 안 됨)   
  3. 부모클래스의 override 메소드 구현 시(이때 private 키워드를 붙이면 안 됨) ->자식이 오버라이딩한 것을 자식의 자식이 오버라이딩하는 것   
override 키워드를 앞에 붙여야 한다.   


### 상속
* sealed 키워드가 없는 클래스를 부모로 지정한 클래스는 해당 부모의 자식이 되어 private 키워드가 아닌 부모의 필드와 메소드를 받아와서 사용할 수 있다   
* 또한, 부모의 메소드를 받아와서 자식에게 필요한 기능을 추가하여 이름만 같은, 완전히 다른 기능을 하는 메소드를 정의 가능하다(override)   
  다만 virtual 키워드가 명시된 부모의 메소드만, 자식은 override 키워드를 명시한 메소드를 이용해 동일한 이름으로 재정의 가능하다   
* 자식이 재정의한 이 메소드에 sealed 키워드를 붙일 경우,   
  이 자식을 부모로 삼은 자식 클래스(부모0세대, 본인1세대, 본인의 자식 2세대)는 해당 메소드를 override 할 수 없다   


### virtual 키워드
[참고](https://zprooo915.tistory.com/11)   
(abstract VS virtual VS interface)   


### 인터페이스 VS 추상클래스(abstract)
우선 개념적으로 인터페이스는 추상클래스의 하위개념이다.   
||인터페이스|추상클래스|
|:-:|:--------:|:--------:|
|추상메소드 비율|모든 메소드|1개 이상 메소드|
|정의|아무것도 설계되지 않은채 밑그림만 있는 설계도|일부가 구현된 설계도|
|다중 상속 가능 여부|가능(인터페이스-클래스, 인터페이스-인터페이스 모두)|불가능|
|기본접근자|public|private|
|구현을 가지는 것|불가능|가능|
|자식 클래스가 override키워드를|안 써도 됨(모든 메소드가 추상메소드라)|꼭 써야 함|   

그렇다면 이 둘은 각자 언제 쓸까?   
1. 인터페이스를 쓰는 경우   
  인터페이스를 설명하려면 다형성(Polymorphism)에 대한 개념이 등장한다.   
  동물이 먹고, 걷고, 자는 것은 공통적인데, 그 것을 행하는 방법이 각자 다르다.   
  고양이는 걸을 때 네발로 걷고, 원숭이는 두발 또는 네발로, 병아리도 두발로..   
  그래서 동물이 먹고, 걷고, 잔다는 틀만 만들어놓고   
  고양이, 원숭이, 병아리는 그 틀안에 자신만의 방법으로 메소드를 구현하는 것이다.   
  반드시 구현체 동물들은 먹고 걷고 자는방법이 구현되어야 한다. 동물이라면..   
  그리고 고양이의 자는법이 달라져도 원숭이, 병아리에게는 아무 영향도 없다.   
2. 추상클래스를 쓰는 경우   
  야생고양이가 새끼를 낳았다. 새끼는 인간에 의해 집고양이가 되었다고하자.   
  ```
  어미고양이(부모클래스) - 야생고양이   
  {   
    - 자는법 (메소드)   
    - 집에서 사는법 (추상화 메소드)
  }
  ```   
  ```
  새끼고양이(자식클래스) - 집고양이
  {
    - 자는법 (메소드)
    - 집에서 사는법 (메소드)
  }
  ```   
  어미고양이는 야생고양이므로 집에서 사는법은 모르지만,   
  새끼고양이에게 집에서 사는법을 알려주기 위해 추상화 메소드로 만들었다.(단 모르니까 구현은 X)   
  어미고양이는 자는법이 있었고, 자식에게 전수하였다.   
  그러나 자식은 집고양이라 어미고양이와 자는법이 달랐다.   
  그래서 자식고양이 나름대로 자는법을 새로 터득하였다.   
  그게 이미 구현되어있는 부모클래스의 내용을 Override를 하는 것이다.   
  새끼고양이는 집 생활을 하며, 어미고양이가 모르는, 집에 사는법을 더 많이 터득하였다.   
  (부모 클래스보다 더 많이 구현되는 경우가 대부분이다)   
   
결론은,   
인터페이스는 다형성이라 생각하면되고,   
추상클래스는 상속의 부모 - 자식 관계..   
부모가 갖고있는 기능을 유전 받으면서, 기능을 더 추가한다거나, 부모의 유전된 기능을 약간 수정할 때 쓴다.   
[출처](https://marobiana.tistory.com/58)


### 추상클래스 VS (가상메소드를 포함한)일반클래스
* 공통점   
  자식클래스에서 상속받아 재정의 시 override 키워드를 추가해야 함   
* 차이점   
  추상클래스 내 추상메소드는 구현을 갖지 못하고, 일반클래스 내 가상메소드는 구현을 가질 수 있다   
   
즉, 추상메소드는 자식클래스가 "반드시" 구현해야 하지만, 가상메소드는 "선택적"으로 구현하면 된다   


### sealed 키워드
상속으로부터 봉인!   
클래스에 sealed 키워드가 포함된 메소드가 있는 경우 상속은 가능하지만(sealed된 메소드만 상속 불가)   
sealed 키워드가 클래스에 붙을 경우 상속 자체가 안 된다   
* 사용 이유   
  위 상속 설명의 마지막 줄 같은 상황에서, 자식의 자식의 자식이... 메소드를 계속해서 오버라이딩하다가 혹여 오류가 발생할 수 있음   
  이 오류가 상속으로 인해 복합적으로 덩어리지지 않도록, 사전에 오류의 크기를 제어하기 위한 방지턱 역할을 함   
  반복적인 상속으로 인해 클래스 설계가 지나치게 복잡해지지 않도록 방지하는 역할을 하기도 함   


### static 키워드 (정적)
모든 객체가 공통되게 사용하는 일정한 값이나 설정 정보같은 공용자원에 대해,   
매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해서 접근하기 위해 사용함    
인스턴스 생성 없이 바로 사용가능 하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리 할 때 이용한다.   
(new 명령어로 인스턴스를 생성하지 않고, Class명.메소드명 / Class명.변수명 이런식으로 접근)   
   
프로그램이 실행하기 전에 static 함수나 static 변수를 첫 단계로 메모리에 올려 프로그램을 실행시킴 (static이 실행시 1순위)   
또한 static 메소드, 클래스, 변수는 프로그램이 종료될 때까지 사라지지 않는다   

* 클래스, 메소드, 변수는 모두 static 키워드를 가질 수 있다   
  static 클래스의 경우 모든 클래스 멤버가 static 멤버로 되어 있음   
  static 메소드와 클래스는 상속(override)할 수 없음   
  static 클래스는 public 생성자(constructor)를 가질 수 없음(static 클래스는 객체를 생성할 수 없으므로)   
  대신 static 기본생성자를 가질 수 있다.(public 클래스명()이 아닌 static 클래스명()이러한 형식을 따른다. 매개변수를 가질 수 없음)   
  이는 주로 static 필드들을 초기화 하는데 사용한다. 따로 호출할 수 없고, 프로그램이 시작될 때 최초로 1번 자동으로 실행된다.   
   
* main함수가 static 키워드를 가진 이유   
main함수가 실행되기 위해서는 메모리에 미리 올라가야함   
(시작점인 main() 메소드를 호출하려고 하는데 메모리에 main이 없으면 실행을 할 수가 없게 되기 때문)   
그래서 main 메소드는 누군가 호출하기 전에 미리 메모리에 있어야 하기 때문에 static을 붙이는 것   
   
* 유의사항   
1. 상속을 통한 다형성을 실현할 수 없다는 점,   
2. 프로그램이 종료될 때까지 소멸하지 않는다는 점, (메모리 문제가 발생할 수 있음)   
3. 멀티스레드 방식에서 한 스레드가 static 값을 변경하면 모든 스레드에 영향을 준다는 점   
등 때문에 신중하게 사용해야 함  


### 확장메소드
static 메소드 중 하나의 종류로, 기존 클래스의 기능을 확장하는 특수한 메소드.   
확장메소드를 포함한 클래스는 무조건 static 클래스이다   
* 선언 방식   
  기존 static 메소드와 동일하되, 첫번째 매개변수는 무조건 "this 자료형식(=이미 정의된 클래스) 매개변수명" 이다.   
  이 매개변수가 곧 이 확장메소드를 호출하는 객체를 뜻한다.   
  ```
  public static int plus(this int a, int b) 
  {
    return a+b; 
  }
  public static void Main()
  {
    int c=2, d=3; 
    c.plus(d);   
  }
  ```
  두번째 매개변수부터는 여타 메소드와 동일하고, 선택적이다.   
* 유의사항   
  매개 변수의 형식과 갯수까지 같을 경우 기존 정의된 메서드가 실행됨   
  확장 메서드의 우선 순위는 인스턴스 메서드보다 낮기 때문에 동일한 메서드 이름을 사용하는 것은 피해야 함   
  ```
  public static string ToString(this int input) 
  {
    return input.ToString() + "kk"; 
  }
  public static void Main()
  {
    int a=2; 
    a.ToString(); // 결과는 "2kk"가 아닌 "2"가 나온다.
  }
  ```
  기존메소드인 ToString()이 이미 존재하기 때문에 얘가 먼저 실행됨   
[](https://slaner.tistory.com/189)


### override vs 확장메소드
* 오버라이딩   
  메소드 오버라이딩은 상속의 연장선으로,   
  일반클래스의 virtual 메소드 → 선언된 메소드의 기존 기능을 재정의   
  추상클래스의 abstract 메소드 → 본문이 없는 기능을 구현하여 정의   
  때문에, 부모 클래스와 자식(나) 클래스는 서로 이어져있으며 서로는 이러한 관계에 얽히게 된다.   
  override된 메소드 → **나(자식)** 가 소유한 기능   
  그 외 virtual로 선언된 메소드를 override하지 않거나, virtual로 선언되어 있지 않은 메소드 → **부모** 가 소유한 기능   
* 확장 메소드   
  반면, 확장 메소드는 확장 메소드를 정의하는 static class와   
  확장할 대상(this 키워드가 붙은 자료형) 간에 아무런 관계도 없으며, 제 3자같은 느낌이 든다. (연예인과 팬 느낌)   
  확장 메소드는 기능을 확장하는 것이 주 역할.   
  많은 팬들(확장메소드)이 연예인(확장 당하는 대상)을 모방함(확장메소드의 구현)으로써 그의 인기(확장 당하는 대상의 기능)를 "확장"시킨단 느낌   


-----
### namespace
class를 구분해서 효율을 높이기 위해 만들어진 개념   
하나의 프로그램 안에 동일한 이름의 클래스는 존재할 수 없지만, namespace를 다르게 지정하면 동일한 이름의 클래스가 존재할 수 있다.   
using [namespace이름]; 형태로 사용하며, 이는 namespace에 포함된 모든 클래스를 사용하겠다는 의미이다.   


### Array(배열) VS ArrayList VS List<>
||Array|ArrayList|List<>|
|:-:|:--------:|:--------:|:---:|
|용량|미리 지정해야 함|미리 지정할 필요없음|미리 지정할 필요없음|
|저장방식|스택 메모리에 연속적인 형태로 저장(검색이 빠름)|포인터로 주소 저장(데이터를 object형식으로 저장)|포인터로 주소 저장|
|단점|중간삽입/삭제가 번거롭다|경우에 따라 배열보다 검색 속도가 느릴 수 있음. object 타입이라 형식이 안전하지 않다|경우에 따라 배열보다 검색 속도가 느릴 수 있음|

[Array를 동적으로 사용하는 법](https://im-first-rate.tistory.com/124)   


### 다차원 배열 VS 가변 배열(Jagged array)   
* 다차원 배열   
  `int [,] a = new int[2,3];`   
* 가변 배열   
  ```
  int [][] a = new int[2][];
  a[0] = { 1, 2, 3, 4, 5 };
  a[1] = { 5, 4, 3 };
  ```   
* 2차원 가변 배열   
  ```
  int [][,] a = new int[2][,]
  {
    new int[,] { {1, 2}, {3, 4}, {5, 6} },
    new int[,] { {1, 2} }
  }
  ```


### delegate VS event 



### Thread VS Task
C# 명령어에서는 Thread도 존재하고 Task도 존재함 둘의 차이가 무엇일까   
   
   
### var VS dynamic
var는 컴파일 시에 데이터 형식이 결정된다. 그래서 한 번 데이터 형식이 결정되면 변경할 수 없다.   
반면 dynamic은 런타임 시 데이터 형식이 결정된다. 그래서 데이터 형식을 자유롭게 바꿀 수 있다.   
```
dynamic a;
a = 1;
a = "kk";
```
가 가능하다.   


### const VS readonly
* 공통점   
  상수를 저장하는 변수에 사용한다.   
* 차이점  
  const는 초기화할 때만 값을 지정할 수 있고,   
  readonly는 초기화할 때랑, 생성자에서 값을 지정할 수 있다.   
   
   
-----    
# Unity


### Coroutine


### 스크립트 실행순서


